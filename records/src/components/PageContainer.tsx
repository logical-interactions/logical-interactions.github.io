import * as React from "react";

import StressTest from "./StressTest";

  // let applications = (<>
  //   <h2>Throttling and Caching</h2>
  //   <h2>Undo/Redo, Logging</h2>
  //   <h3>Scenting</h3>
  //   <h3>Notebook</h3>
  //   <p>Jupyter Notebooks are wildly popular, and one of the reasons is that just as real notebooks, we tend to save previous results. This can help us think better (see literature in distributed cognition).</p>
  // </>);
export const PageContainer = () => (<>
  <h1>Programming Asynchronous Interactions: History of Intentions</h1>
  <h3 style={{textAlign: "right", lineHeight: "70%"}}>Let's Make (UI) History!</h3>
  <p>
    Interactive visualizations is a great tool for working with data with lower cognitive overhead.  However creating a custom interactive visualization for datasets that cannot fit on a browser is very complicated, where heavily customized code seems the only option. <a href=" https://github.com/mapd/mapd-crossfilter/blob/master/src/mapd-crossfilter.js ">MapD's asynchronous crossfilter that talks to their relational backend</a>.
  </p>
  <h2>
    This post is about how we can tame the complexity of creating data-processing interactions frontend applications.
  </h2>
  <p>
    The primary insight is ... #FIXME
  </p>
  <p>
    We will walk through two main examples to illustrate how the framework is applied.
  </p>
  {/* <XFilterContainer /> */}
  {/* <AsyncContainer /> */}
  {/* <Test /> */}
  {/* <StressTest /> */}
</>);